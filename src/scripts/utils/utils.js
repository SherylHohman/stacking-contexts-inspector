/**
 * Get a list of JSON-friendly stacking contexts that have only the context id set as the parent/children, and links them.
 * 
 * @param {Array<Object>} contextsList A list of contexts with their  
 * @returns {Object} A representation of a stacking context adapted for the devtools scripts.
 */
export function generateContextTree(contextsList) {
    let root = contextsList[0];

    function linkChildren(context) {
        // Get a context from its id (since the ids start from 0, the id is also its index inside the array)
        context.children = context.children.map( (child) => contextsList[child] );
        for (let child of context.children) {
            child.parent = context;
            linkChildren(child);
        }
    }

    linkChildren(root);

    return root;
}

export function isValuableContainer(container) {
    // Check if has children
    if (container.children.length == 0) return false;
    
    // Check if some children is a stacking context
    if (container.children.some((child) => child.type !== "container")) return true;

    // Check the container children to see if they're valuable to show
    if (container.children.some((child) => isValuableContainer(child))) return true;

    return false;
}

/**
 * This function returns an array of objects that represent the path that it takes to get from the main document to an element
 * regardless if it is inside an iframe, a shadow DOM or multiples of them. It walks up the documents until it reaches the main one.
 * If the element is inside a closed shadow root it will be unreachable, and "null" will be returned.
 * 
 * !!! This function will be executed from its string representation, do not use other custom functions inside of it!
 * 
 * @param {Node} node 
 * @returns {Object[] | null}
 */
export function getPathFromNode(node) {
    
    let curElement = node;
    let path = [];
    let curRoot = null;

    do {
        // get root node of current element. Might be a shadow-root or an iframe document
        curRoot = curElement.getRootNode();
        

        let pathFragment = {
            index: Array.from(curRoot.querySelectorAll('*')).findIndex((el) => el === curElement),
            type: "document"
        }
    
        if (curRoot instanceof ShadowRoot) {
            // element is inside a shadowRoot
            pathFragment.type = "shadow";
            
            // if it's inside a closed shadow root, just return null, since it will be unreachable from the outside
            if (curRoot.mode === "closed") {
                return null;
            }
            
            curElement = curRoot.host;
        }
        else if (curRoot !== document) {
            // is inside an iframe
            pathFragment.type = "iframe";

            curElement = curRoot.defaultView.frameElement;
        }
    
        path.push(pathFragment);

    } while (curRoot !== document);

    return path.reverse();
}

/**
 * Get a Node from the path generated by the getPathFromNode function
 * 
 * @param {Object} path 
 * @returns {Node}
 */
export function getNodeFromPath(path) {
    
    let curElement = null;

    const elementFromIndex = (container, index) => container.querySelectorAll('*')[index];

    for (let pathFragment of path) {
        switch (pathFragment.type) {
            case "document":
                curElement = elementFromIndex(document, pathFragment.index);
                break;
            case "shadow":
                curElement = elementFromIndex(curElement.shadowRoot, pathFragment.index);
                break;
            case "iframe":
                curElement = elementFromIndex(curElement.contentDocument, pathFragment.index);
                break;
        }
    }

    return curElement;
}